{"version":3,"sources":["src/CubemapAdapter.ts","src/utils.ts"],"sourcesContent":["import type { PanoramaPosition, Position, TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, PSVError, SYSTEM, utils } from '@photo-sphere-viewer/core';\nimport { BoxGeometry, MathUtils, Mesh, MeshBasicMaterial, Texture, Vector2, Vector3 } from 'three';\nimport {\n    Cubemap,\n    CubemapAdapterConfig,\n    CubemapData,\n    CubemapFaces,\n    CubemapNet,\n    CubemapPanorama,\n    CubemapSeparate,\n    CubemapStripe,\n} from './model';\nimport { cleanCubemap, cleanCubemapArray, isCubemap } from './utils';\n\ntype CubemapMesh = Mesh<BoxGeometry, MeshBasicMaterial[]>;\ntype CubemapTextureData = TextureData<Texture[], CubemapPanorama, CubemapData>;\n\nconst getConfig = utils.getConfigParser<CubemapAdapterConfig>({\n    blur: false,\n});\n\nconst EPS = 0.000001;\nconst ORIGIN = new Vector3();\n\n/**\n * Adapter for cubemaps\n */\nexport class CubemapAdapter extends AbstractAdapter<CubemapPanorama, CubemapData, Texture[], CubemapMesh> {\n    static override readonly id = 'cubemap';\n    static override readonly VERSION = PKG_VERSION;\n    static override readonly supportsDownload = false;\n\n    private readonly config: CubemapAdapterConfig;\n\n    constructor(viewer: Viewer, config: CubemapAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n    }\n\n    override supportsTransition() {\n        return true;\n    }\n\n    override supportsPreload() {\n        return true;\n    }\n\n    /**\n     * {@link https://github.com/bhautikj/vrProjector/blob/master/vrProjector/CubemapProjection.py#L130}\n     */\n    override textureCoordsToSphericalCoords(point: PanoramaPosition, data: CubemapData): Position {\n        if (utils.isNil(point.textureX) || utils.isNil(point.textureY) || utils.isNil(point.textureFace)) {\n            throw new PSVError(`Texture position is missing 'textureX', 'textureY' or 'textureFace'`);\n        }\n\n        const u = 2 * (point.textureX / data.faceSize - 0.5);\n        const v = 2 * (point.textureY / data.faceSize - 0.5);\n\n        function yawPitch(x: number, y: number, z: number): [number, number] {\n            const dv = Math.sqrt(x * x + y * y + z * z);\n            return [Math.atan2(y / dv, x / dv), -Math.asin(z / dv)];\n        }\n\n        let yaw: number;\n        let pitch: number;\n        switch (point.textureFace) {\n            case 'front':\n                [yaw, pitch] = yawPitch(1, u, v);\n                break;\n            case 'right':\n                [yaw, pitch] = yawPitch(-u, 1, v);\n                break;\n            case 'left':\n                [yaw, pitch] = yawPitch(u, -1, v);\n                break;\n            case 'back':\n                [yaw, pitch] = yawPitch(-1, -u, v);\n                break;\n            case 'bottom':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(-v, u, 1) : yawPitch(v, -u, 1);\n                break;\n            case 'top':\n                [yaw, pitch] = data.flipTopBottom ? yawPitch(v, u, -1) : yawPitch(-v, -u, -1);\n                break;\n        }\n\n        return { yaw, pitch };\n    }\n\n    override sphericalCoordsToTextureCoords(position: Position, data: CubemapData): PanoramaPosition {\n        // @ts-ignore\n        const raycaster = this.viewer.renderer.raycaster;\n        // @ts-ignore\n        const mesh = this.viewer.renderer.mesh;\n        raycaster.set(ORIGIN, this.viewer.dataHelper.sphericalCoordsToVector3(position));\n        const point = raycaster.intersectObject(mesh)[0].point.divideScalar(CONSTANTS.SPHERE_RADIUS);\n\n        function mapUV(x: number, a1: number, a2: number): number {\n            return Math.round(MathUtils.mapLinear(x, a1, a2, 0, data.faceSize));\n        }\n\n        let textureFace: CubemapFaces;\n        let textureX: number;\n        let textureY: number;\n        if (1 - Math.abs(point.z) < EPS) {\n            if (point.z > 0) {\n                textureFace = 'front';\n                textureX = mapUV(point.x, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'back';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else if (1 - Math.abs(point.x) < EPS) {\n            if (point.x > 0) {\n                textureFace = 'left';\n                textureX = mapUV(point.z, -1, 1);\n                textureY = mapUV(point.y, 1, -1);\n            } else {\n                textureFace = 'right';\n                textureX = mapUV(point.z, 1, -1);\n                textureY = mapUV(point.y, 1, -1);\n            }\n        } else {\n            if (point.y > 0) {\n                textureFace = 'top';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, 1, -1);\n            } else {\n                textureFace = 'bottom';\n                textureX = mapUV(point.x, -1, 1);\n                textureY = mapUV(point.z, -1, 1);\n            }\n            if (data.flipTopBottom) {\n                textureX = data.faceSize - textureX;\n                textureY = data.faceSize - textureY;\n            }\n        }\n\n        return { textureFace, textureX, textureY };\n    }\n\n    async loadTexture(panorama: CubemapPanorama, loader = true): Promise<CubemapTextureData> {\n        if (this.viewer.config.fisheye) {\n            utils.logWarn('fisheye effect with cubemap texture can generate distorsion');\n        }\n\n        let cleanPanorama: CubemapSeparate | CubemapStripe | CubemapNet;\n        if (Array.isArray(panorama) || isCubemap(panorama)) {\n            cleanPanorama = {\n                type: 'separate',\n                paths: panorama,\n            } as CubemapSeparate;\n        } else {\n            cleanPanorama = panorama as any;\n        }\n\n        let result: { textures: Texture[]; flipTopBottom: boolean; cacheKey: string };\n        switch (cleanPanorama.type) {\n            case 'separate':\n                result = await this.loadTexturesSeparate(cleanPanorama, loader);\n                break;\n\n            case 'stripe':\n                result = await this.loadTexturesStripe(cleanPanorama, loader);\n                break;\n\n            case 'net':\n                result = await this.loadTexturesNet(cleanPanorama, loader);\n                break;\n\n            default:\n                throw new PSVError('Invalid cubemap panorama, are you using the right adapter?');\n        }\n\n        return {\n            panorama,\n            texture: result.textures,\n            cacheKey: result.cacheKey,\n            panoData: {\n                isCubemap: true,\n                flipTopBottom: result.flipTopBottom,\n                faceSize: (result.textures[0].image as HTMLImageElement | HTMLCanvasElement).width,\n            },\n        };\n    }\n\n    private async loadTexturesSeparate(panorama: CubemapSeparate, loader: boolean) {\n        let paths: string[];\n        if (Array.isArray(panorama.paths)) {\n            paths = cleanCubemapArray(panorama.paths as string[]);\n        } else {\n            paths = cleanCubemap(panorama.paths as Cubemap);\n        }\n\n        const cacheKey = paths[0];\n        const promises: Array<Promise<Texture>> = [];\n        const progress = [0, 0, 0, 0, 0, 0];\n\n        for (let i = 0; i < 6; i++) {\n            if (!paths[i]) {\n                progress[i] = 100;\n                promises.push(Promise.resolve(null));\n            } else {\n                promises.push(\n                    this.viewer.textureLoader\n                        .loadImage(\n                            paths[i],\n                            loader\n                                ? (p) => {\n                                        progress[i] = p;\n                                        this.viewer.loader.setProgress(utils.sum(progress) / 6);\n                                    }\n                                : null,\n                            cacheKey,\n                        )\n                        .then(img => this.createCubemapTexture(img)),\n                );\n            }\n        }\n\n        return {\n            textures: await Promise.all(promises),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private createCubemapTexture(img: HTMLImageElement): Texture {\n        if (img.width !== img.height) {\n            utils.logWarn('Invalid cubemap image, the width should equal the height');\n        }\n\n        // resize image\n        if (this.config.blur || img.width > SYSTEM.maxTextureWidth) {\n            const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.width);\n\n            const buffer = new OffscreenCanvas(Math.floor(img.width * ratio), Math.floor(img.height * ratio));\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(img, 0, 0, buffer.width, buffer.height);\n\n            return utils.createTexture(buffer);\n        }\n\n        return utils.createTexture(img);\n    }\n\n    private async loadTexturesStripe(panorama: CubemapStripe, loader: boolean) {\n        if (!panorama.order) {\n            panorama.order = ['left', 'front', 'right', 'back', 'top', 'bottom'];\n        }\n\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? p => this.viewer.loader.setProgress(p) : null,\n            cacheKey,\n        );\n\n        if (img.width !== img.height * 6) {\n            utils.logWarn('Invalid cubemap image, the width should be six times the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / img.height);\n        const tileWidth = Math.floor(img.height * ratio);\n\n        const textures = {} as Record<CubemapFaces, Texture>;\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = new OffscreenCanvas(tileWidth, tileWidth);\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(\n                img,\n                img.height * i, 0,\n                img.height, img.height,\n                0, 0,\n                tileWidth, tileWidth,\n            );\n\n            textures[panorama.order[i]] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures: cleanCubemap(textures),\n            cacheKey,\n            flipTopBottom: panorama.flipTopBottom ?? false,\n        };\n    }\n\n    private async loadTexturesNet(panorama: CubemapNet, loader: boolean) {\n        const cacheKey = panorama.path;\n        const img = await this.viewer.textureLoader.loadImage(\n            panorama.path,\n            loader ? p => this.viewer.loader.setProgress(p) : null,\n            cacheKey,\n        );\n\n        if (img.width / 4 !== img.height / 3) {\n            utils.logWarn('Invalid cubemap image, the width should be 4/3rd of the height');\n        }\n\n        const ratio = Math.min(1, SYSTEM.maxCanvasWidth / (img.width / 4));\n        const tileWidth = Math.floor((img.width / 4) * ratio);\n\n        const pts = [\n            [0, 1 / 3], // left\n            [1 / 2, 1 / 3], // right\n            [1 / 4, 0], // top\n            [1 / 4, 2 / 3], // bottom\n            [3 / 4, 1 / 3], // back\n            [1 / 4, 1 / 3], // front\n        ];\n\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < 6; i++) {\n            const buffer = new OffscreenCanvas(tileWidth, tileWidth);\n\n            const ctx = buffer.getContext('2d');\n\n            if (this.config.blur) {\n                ctx.filter = `blur(${buffer.width / 512}px)`;\n            }\n\n            ctx.drawImage(\n                img,\n                img.width * pts[i][0], img.height * pts[i][1],\n                img.width / 4, img.height / 3,\n                0, 0,\n                tileWidth, tileWidth,\n            );\n\n            textures[i] = utils.createTexture(buffer);\n        }\n\n        return {\n            textures,\n            cacheKey,\n            flipTopBottom: true,\n        };\n    }\n\n    createMesh(): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize).scale(1, 1, -1);\n\n        const materials: MeshBasicMaterial[] = [];\n        for (let i = 0; i < 6; i++) {\n            const material = new MeshBasicMaterial({ depthTest: false, depthWrite: false });\n            materials.push(material);\n        }\n\n        return new Mesh(geometry, materials);\n    }\n\n    setTexture(mesh: CubemapMesh, { texture, panoData }: CubemapTextureData) {\n        mesh.material.forEach((material, i) => {\n            if (texture[i]) {\n                if (panoData.flipTopBottom && (i === 2 || i === 3)) {\n                    texture[i].center = new Vector2(0.5, 0.5);\n                    texture[i].rotation = Math.PI;\n                }\n\n                material.map = texture[i];\n            } else {\n                material.opacity = 0;\n                material.transparent = true;\n            }\n        });\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        mesh.material.forEach((material) => {\n            if (material.map) {\n                material.opacity = opacity;\n                material.transparent = opacity < 1;\n            }\n        });\n    }\n\n    disposeTexture({ texture }: CubemapTextureData): void {\n        texture.forEach(t => t.dispose());\n    }\n\n    disposeMesh(mesh: CubemapMesh): void {\n        mesh.geometry.dispose();\n        mesh.material.forEach(m => m.dispose());\n    }\n}\n","import { PSVError } from '@photo-sphere-viewer/core';\nimport { Cubemap, CubemapFaces } from './model';\n\n// PSV faces order is left, front, right, back, top, bottom\n// 3JS faces order is left, right, top, bottom, back, front\nconst CUBE_ARRAY = [0, 2, 4, 5, 3, 1];\nconst CUBE_HASHMAP: CubemapFaces[] = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nexport function isCubemap(cubemap: any): cubemap is Cubemap {\n    return cubemap && typeof cubemap === 'object' && CUBE_HASHMAP.every(side => side in cubemap);\n}\n\n/**\n * Given an array of 6 objects in PSV order, returns an array in 3JS order\n */\nexport function cleanCubemapArray<T>(panorama: T[]): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (panorama.length !== 6) {\n        throw new PSVError('A cubemap array must contain exactly 6 images.');\n    }\n\n    // reorder images\n    for (let i = 0; i < 6; i++) {\n        cleanPanorama[i] = panorama[CUBE_ARRAY[i]];\n    }\n\n    return cleanPanorama;\n}\n\n/**\n * Given an object where keys are faces names, returns an array in 3JS order\n */\nexport function cleanCubemap<T>(cubemap: Record<CubemapFaces, T>): T[] {\n    const cleanPanorama: T[] = [];\n\n    if (!isCubemap(cubemap)) {\n        throw new PSVError('A cubemap object must contain exactly left, front, right, back, top, bottom images.');\n    }\n\n    // transform into array\n    CUBE_HASHMAP.forEach((side, i) => {\n        cleanPanorama[i] = (cubemap as any)[side];\n    });\n\n    return cleanPanorama;\n}\n"],"mappings":"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","names":["PSVError","PSVError"]}